# helper module used by the multi-match-query. It takes a list of fieldnames (or a hash with
# containing the query-time boost factors as values) and returns a function that
# transforms an AST as generated by the query-parser into an Elasticsearch Query.
ConfigNode = require "../config-node"
Merge = require "../merger"
{Rewrite} = require "../ast-rewrite-rules"
merge = Merge()
{isArray} = require "util"
empty = (thing)->
  if not thing?
    return true
  if isArray(thing) and thing.length is 0
    return true
  if typeof thing is "object" and Object.keys(thing).length is 0
    return true
  
joinConsecutiveTerms = (done, next)->
  [nextOp, nextArgs...] = next
  [prefix..., prev] = done
  [prevOp, prevArgs...] = (prev ? [])

  
  if prevOp is 'TERM' and nextOp is 'TERM'
    [prefix..., [prevOp, prevArgs..., nextArgs...]]
  else
    [done..., next]


groupBy = (crit)->
  reducer = (groups={}, elm)->
    c = crit elm
    group = groups[c] ?= []
    group.push elm
    groups
    
builtInTransform = (ast, cx)->
  [opc, operands...] = ast
  {fieldBoosts, defaultOperator, transformChild} = cx
  switch opc
    when 'QLF'
      #TODO just pass through the rhs for now
      transformChild(cx) operands[1]
    when 'TERM'
      multi_match:
        query: operands.join ' '
        type: 'cross_fields'
        fields: fieldBoosts
        operator: defaultOperator
    when "DQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "SQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "OR"
      bool:
        should: operands.map transformChild cx
    when "AND"
      bool:
        must: operands.map transformChild cx
    when "NOT"
      bool:
        must_not: operands.map transformChild cx
    when "SEQ"
      # the children are guaranteed to be occurence annotations
      # Group children by occurence
      groups =  operands.reduce (groupBy (t)->t[0]), {}
      # create a boolean query
      boolBody = {}
      totalClauses = 0
      for occ,elms of groups
        clauses = elms
          .map (t)->t[1]
          .reduce joinConsecutiveTerms, []
          .map transformChild(cx)
        boolBody[occ.toLowerCase()] = clauses
        totalClauses += clauses.length
        
      # if there is only one clause, and if it
      # is not negative, we don't need the bool query at all.
      if totalClauses is 1 and occ isnt "MUST_NOT"
        clauses[0]
      else
        bool: boolBody
    else
      match_all:{}

module.exports = class AstTransformer extends ConfigNode

  queryFields: (attrs)->
    queryFields = {}
    if @_options.fields?
      return @_options.fields

    for attr in attrs when attr.query
      fieldName = if attr.includeSubfields then attr.field+"*" else attr.field
      queryFields[fieldName] = attr.boost ? 1
    queryFields

  transform: (ast0, attributes, query)->
    queryFields = @queryFields attributes
    if empty(queryFields)
      return {}
    fieldBoosts = if isArray(queryFields) then queryFields else ("#{fieldName}^#{boost}" for fieldName, boost of queryFields)
    fieldNames = if isArray(queryFields) then queryFields else Object.keys queryFields

    defaultOperator = query?.qop ? @_options?.defaultOperator ? "and"
    defaultOccurence = if defaultOperator is "and" then "MUST" else "SHOULD"
    rewrite = Rewrite defaultOccurence
    {value:ast} = rewrite ast0
    


    customize = @_options.customize
    customizedTransform = (ast, cx)->
      [operation, operands...] = ast
      part0 =builtInTransform ast, cx

      customization = customize?[operation] ? {}
      if typeof customization is "function"
        customization operands, customizedTransform, part0
      else if typeof customization is "object"
        merge part0, customization

    transformChild =(cx)->(child)->customizedTransform child, cx
    cx0 ={queryFields,attributes,fieldNames, fieldBoosts, defaultOperator, transformChild}

    body = (if ast?.length > 0 then customizedTransform(ast, cx0) else {})
    @postProcess body, cx0

  postProcess: (body, options)->
    if @_options?.postProcess?
      @_options.postProcess body, options
    else
      body
