# helper module used by the multi-match-query. It takes a list of fieldnames (or a hash with
# containing the query-time boost factors as values) and returns a function that
# transforms an AST as generated by the query-parser into an Elasticsearch Query.
ConfigNode = require "../config-node"
Merge = require "../merger"
{Rewrite} = require "../ast-rewrite-rules"
merge = Merge()
{isArray} = require "util"
empty = (thing)->
  if not thing?
    return true
  if isArray(thing) and thing.length is 0
    return true
  if typeof thing is "object" and Object.keys(thing).length is 0
    return true
  
joinConsecutiveTerms = (occ)->
  # note that we use operator: or for occ==NOT. This works because De Morgan:
  # NOT (A or B or C ...) is equivalent to NOT A and NOT B and NOT C
  operator = if occ is "MUST" then "and" else "or"
  (done, next)->
    [nextOp, nextArgs...] = next
    [prefix..., prev] = done
    [prevOp, prevArgs...] = (prev ? [])

    switch
      when prevOp is 'TERM' and nextOp is 'TERM'
        [prefix..., ['TERMS',operator, prevArgs..., nextArgs...]]
      when prevOp is 'TERMS' and nextOp is 'TERM'
        [prefix..., ['TERMS', prevArgs..., nextArgs...]]
      else
        [done..., next]

groupBy = (crit)->
  reducer = (groups={}, elm)->
    c = crit elm
    group = groups[c] ?= []
    group.push elm
    groups
    
builtInTransform = (ast, cx)->
  [opc, operands...] = ast
  {fieldBoosts, defaultOperator, transformChild} = cx
  switch opc
    when 'QLF'
      # just pass through the rhs for now
      # applications can define their own semantics e.g. by defining a context transform
      transformChild(cx) operands[1]
    when 'TERM'
      multi_match:
        query: operands.join ' '
        type: 'cross_fields'
        fields: fieldBoosts
        operator: defaultOperator
    when 'TERMS' # pseudo node, created for consecutive non-negative terms
      [operator, actualTerms...] = operands
      multi_match:
        query: actualTerms.join ' '
        type: 'cross_fields'
        fields: fieldBoosts
        operator: operator
    when "DQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "SQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "OR", "SHOULD"
      bool:
        should: operands.map transformChild cx
    when "AND","MUST"
      bool:
        must: operands.map transformChild cx
    when "NOT", "MUST_NOT"
      bool:
        must_not: operands.map transformChild cx
    when "SEQ"
      # the children are guaranteed to be occurence annotations
      # Group children by occurence
      groups =  operands.reduce (groupBy (t)->t[0]), {}

      # join consecutive terms within groups and
      # collect the resulting clauses into pseudo-terms.
      pseudoTerms = Object.keys(groups)
        .map (occ)->
          operands = groups[occ]
            .map (t)->t[1]
            .reduce joinConsecutiveTerms(occ), []
          [occ, operands...]

      # count the resulting clauses
      totalClauses = pseudoTerms.reduce(
        (sum, pseudoTerm)->sum + pseudoTerm.length - 1 # (don't count the head!)
        0
      )

      # special case:
      # if there is only one non-negative clause, we can take a short-cut.
      # In this case, we do not need the boolean query at all.
      if totalClauses is 1 and pseudoTerms[0][0] isnt "MUST_NOT"
        transformChild(cx)(pseudoTerms[0][1])
      else
        # otherwise we recurse on the pseudo terms and merge the results
        pseudoTerms
          .map transformChild cx
          .reduce ((body, transformedClause)->merge body, transformedClause), {}

    else
      match_all:{}

module.exports = class AstTransformer extends ConfigNode

  queryFields: (attrs)->
    queryFields = {}
    if @_options.fields?
      return @_options.fields

    for attr in attrs when attr.query
      fieldName = if attr.includeSubfields then attr.field+"*" else attr.field
      queryFields[fieldName] = attr.boost ? 1
    queryFields

  transform: (ast0, attributes, query)->
    queryFields = @queryFields attributes
    if empty(queryFields)
      return {}
    fieldBoosts = if isArray(queryFields)
      queryFields
    else
      ("#{fieldName}^#{boost}" for fieldName, boost of queryFields)
    fieldNames = if isArray(queryFields) then queryFields else Object.keys queryFields

    defaultOperator = query?.qop ? @_options?.defaultOperator ? "and"
    defaultOccurence = if defaultOperator is "and" then "MUST" else "SHOULD"
    rewrite = Rewrite defaultOccurence
    {value:ast} = rewrite ast0
    

    customize = @_options.customize
    transformContext =@_options.transformContext

    customizedTransform = (ast, cx0)->
      [operation, operands...] = ast
      customization = customize?[operation] ? {}
      transformCx = transformContext?[operation] ? ()->{}
      cx = (if transformCx.length > 1
        transformCx operands, cx
      else
        merge cx0, transformCx operands
      )
      part0 =builtInTransform ast, cx
      

      if typeof customization is "function"
        customization operands, cx, part0
      else if typeof customization is "object"
        merge part0, customization

    transformChild =(cx)->(child)->customizedTransform child, cx
    cx0 ={queryFields,attributes, fieldBoosts, fieldNames, defaultOperator, transformChild}

    body = (if ast?.length > 0 then customizedTransform(ast, cx0) else {})
    @postProcess body, cx0

  postProcess: (body, options)->
    if @_options?.postProcess?
      @_options.postProcess body, options
    else
      body
