# helper module used by the multi-match-query. It takes a list of fieldnames (or a hash with
# containing the query-time boost factors as values) and returns a function that
# transforms an AST as generated by the query-parser into an Elasticsearch Query.
{ ConfigNode, Merger } = require "@l.degener/irma-config"
{Rewrite} = require "@l.degener/irma-query-syntax"
merge = Merger()
{isArray} = require "util"
empty = (thing)->
  if not thing?
    return true
  if isArray(thing) and thing.length is 0
    return true
  if typeof thing is "object" and Object.keys(thing).length is 0
    return true

joinConsecutiveTerms = (occ)->
  # note that we use operator: or for occ==NOT. This works because De Morgan:
  # NOT (A or B or C ...) is equivalent to NOT A and NOT B and NOT C
  operator = if occ is "MUST" then "and" else "or"
  (done, next)->
    [nextOp, nextArgs...] = next
    [prefix..., prev] = done
    [prevOp, prevArgs...] = (prev ? [])

    switch
      when prevOp is 'TERM' and nextOp is 'TERM'
        [prefix..., ['TERMS',operator, prevArgs..., nextArgs...]]
      when prevOp is 'TERMS' and nextOp is 'TERM'
        [prefix..., ['TERMS', prevArgs..., nextArgs...]]
      else
        [done..., next]

groupBy = (crit)->
  reducer = (groups={}, elm)->
    c = crit elm
    group = groups[c] ?= []
    group.push elm
    groups

builtInTransform = (ast, cx)->
  [opc, operands...] = ast
  {fieldBoosts, defaultOperator, transformChild, applyQualifier} = cx
  switch opc
    when 'QLF'
      qualifiedCx = applyQualifier operands[0], cx
      transformChild(qualifiedCx) operands[1]
    when 'TERM'
      multi_match:
        query: operands.join ' '
        type: 'cross_fields'
        fields: fieldBoosts
        operator: defaultOperator
    when 'TERMS' # pseudo node, created for consecutive non-negative terms
      [operator, actualTerms...] = operands
      multi_match:
        query: actualTerms.join ' '
        type: 'cross_fields'
        fields: fieldBoosts
        operator: operator
    when "DQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "SQUOT"
      multi_match:
        query: operands.join ' '
        type: 'phrase'
        fields: fieldBoosts
    when "OR", "SHOULD"
      bool:
        should: operands.map transformChild cx
    when "AND","MUST"
      bool:
        must: operands.map transformChild cx
    when "NOT", "MUST_NOT"
      bool:
        must_not: operands.map transformChild cx
    when "SEQ"
      # the children are guaranteed to be occurence annotations
      # Group children by occurence
      groups =  operands.reduce (groupBy (t)->t[0]), {}

      # join consecutive terms within groups and
      # collect the resulting clauses into pseudo-terms.
      pseudoTerms = Object.keys(groups)
        .map (occ)->
          operands = groups[occ]
            .map (t)->t[1]
            .reduce joinConsecutiveTerms(occ), []
          [occ, operands...]

      # count the resulting clauses
      totalClauses = pseudoTerms.reduce(
        (sum, pseudoTerm)->sum + pseudoTerm.length - 1 # (don't count the head!)
        0
      )

      # special case:
      # if there is only one non-negative clause, we can take a short-cut.
      # In this case, we do not need the boolean query at all.
      if totalClauses is 1 and pseudoTerms[0][0] isnt "MUST_NOT"
        transformChild(cx)(pseudoTerms[0][1])
      else
        # otherwise we recurse on the pseudo terms and merge the results
        pseudoTerms
          .map transformChild cx
          .reduce ((body, transformedClause)->merge body, transformedClause), {}

    else
      match_all:{}

module.exports = class AstTransformer extends ConfigNode

  queryFields: (attrs)->
    queryFields = {}
    if @_options.fields?
      return @_options.fields

    for attr in attrs when attr.query
      subfields = attr.includeSubfields
      if subfields is true
        subfields = {'*':1}
      subfields ?= {}
      queryFields[attr.field] = attr.boost ? 1
      for subField, subFieldBoost of subfields
        queryFields[attr.field+"."+subField] = subFieldBoost * (attr.boost ? 1)
    queryFields

  transform: (ast0, attributes, query)->
    queryFields = @queryFields attributes
    if empty(queryFields)
      return {}
    fieldBoosts = if isArray(queryFields)
      queryFields
    else
      ("#{fieldName}^#{boost}" for fieldName, boost of queryFields)
    fieldNames = if isArray(queryFields) then queryFields else Object.keys queryFields

    defaultOperator = query?.qop ? @_options?.defaultOperator ? "and"
    defaultOccurence = if defaultOperator is "and" then "MUST" else "SHOULD"
    rewrite = Rewrite defaultOccurence
    {value:ast} = rewrite ast0


    customize = @_options.customize
    fieldQualifiers = @_options.fieldQualifiers ? {}
    fieldName = (s)->
      if '^' in s then s.substr 0, s.indexOf '^' else s
    applyQualifier = (qualifier, cx0)->
      {fieldBoosts} = cx0
      predicate = fieldQualifiers[qualifier]
      fieldBoosts = switch
        when not predicate?
          []
        when typeof predicate is "function"
          fieldBoosts.filter predicate
        when typeof predicate is "string"
          fieldBoosts.filter (s)->fieldName(s) is predicate
        when Array.isArray(predicate) and predicate.every((p)->typeof p is "string")
          fieldBoosts.filter (s)->fieldName(s) in predicate
        else
          throw new Error "not a valid field qualifier: #{qualifier}"
      merge cx0, {fieldBoosts}



    customizedTransform = (ast, cx)->
      [operation, operands...] = ast
      customization = customize?[operation] ? {}
      part0 =builtInTransform ast, cx


      if typeof customization is "function"
        customization operands, cx, part0
      else if typeof customization is "object"
        merge part0, customization

    transformChild =(cx)->(child)->customizedTransform child, cx
    cx0 ={queryFields,attributes, fieldBoosts, fieldNames, defaultOperator, transformChild, applyQualifier}

    body = (if ast?.length > 0 then customizedTransform(ast, cx0) else {})
    @postProcess body, cx0

  postProcess: (body, options)->
    if @_options?.postProcess?
      @_options.postProcess body, options
    else
      body
